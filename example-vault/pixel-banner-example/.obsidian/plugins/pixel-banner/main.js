/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.js
var import_obsidian2 = require("obsidian");

// src/settings.js
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiProvider: "pexels",
  pexelsApiKey: "",
  pixabayApiKey: "",
  imageSize: "medium",
  imageOrientation: "landscape",
  numberOfImages: 10,
  defaultKeywords: "nature, abstract, landscape, technology, art, cityscape, wildlife, ocean, mountains, forest, space, architecture, food, travel, science, music, sports, fashion, business, education, health, culture, history, weather, transportation, industry, people, animals, plants, patterns",
  yPosition: 50,
  // Update these fields to be arrays
  customBannerField: ["banner"],
  customYPositionField: ["banner-y"],
  customContentStartField: ["content-start"],
  customImageDisplayField: ["banner-display"],
  customImageRepeatField: ["banner-repeat"],
  folderImages: [],
  contentStartPosition: 150,
  imageDisplay: "cover",
  imageRepeat: false
};
var FolderSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, onChoose) {
    super(app);
    this.onChoose = onChoose;
  }
  getItems() {
    return this.app.vault.getAllLoadedFiles().filter((file) => file.children).map((folder) => folder.path);
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item) {
    this.onChoose(item);
  }
};
var FolderImageSetting = class extends import_obsidian.Setting {
  constructor(containerEl, plugin, folderImage, index, onDelete) {
    super(containerEl);
    this.plugin = plugin;
    this.folderImage = folderImage;
    this.index = index;
    this.onDelete = onDelete;
    this.setClass("folder-image-setting");
    this.settingEl.empty();
    const infoEl = this.settingEl.createDiv("setting-item-info");
    infoEl.createDiv("setting-item-name");
    infoEl.createDiv("setting-item-description");
    this.addFolderInput();
    this.addImageInput();
    this.addImageDisplaySettings();
    this.addPositions();
  }
  addFolderInput() {
    const folderInputContainer = this.settingEl.createDiv("folder-input-container");
    const folderInput = new import_obsidian.Setting(folderInputContainer).setName("folder path").addText((text) => {
      text.setValue(this.folderImage.folder || "").onChange(async (value) => {
        this.folderImage.folder = value;
        await this.plugin.saveSettings();
      });
      this.folderInputEl = text.inputEl;
      this.folderInputEl.style.width = "300px";
    });
    folderInput.addButton((button) => button.setButtonText("Browse").onClick(() => {
      new FolderSuggestModal(this.plugin.app, (chosenPath) => {
        this.folderImage.folder = chosenPath;
        this.folderInputEl.value = chosenPath;
        this.plugin.saveSettings();
      }).open();
    }));
  }
  addImageInput() {
    const folderInputContainer = this.settingEl.createDiv("folder-input-container");
    const imageInput = new import_obsidian.Setting(folderInputContainer).setName("image url or keyword").addText((text) => {
      text.setValue(this.folderImage.image || "").onChange(async (value) => {
        this.folderImage.image = value;
        await this.plugin.saveSettings();
      });
      this.imageInputEl = text.inputEl;
      this.imageInputEl.style.width = "306px";
    });
  }
  addImageDisplaySettings(containerEl) {
    const displayContainer = this.settingEl.createDiv("display-and-repeat-container");
    const displaySetting = new import_obsidian.Setting(displayContainer).setName("image display").addDropdown((dropdown) => {
      dropdown.addOption("auto", "Auto").addOption("cover", "Cover").addOption("contain", "Contain").setValue(this.folderImage.imageDisplay || "cover").onChange(async (value) => {
        this.folderImage.imageDisplay = value;
        await this.plugin.saveSettings();
      });
      dropdown.selectEl.style.marginRight = "20px";
    });
    const repeatSetting = new import_obsidian.Setting(displayContainer).setName("repeat").addToggle((toggle) => {
      toggle.setValue(this.folderImage.imageRepeat || false).onChange(async (value) => {
        this.folderImage.imageRepeat = value;
        await this.plugin.saveSettings();
      });
    });
    const toggleEl = repeatSetting.controlEl.querySelector(".checkbox-container");
    if (toggleEl) toggleEl.style.justifyContent = "flex-start";
  }
  addPositions() {
    const controlEl = this.settingEl.createDiv("setting-item-control");
    this.addYPositionInput(controlEl);
    this.addContentStartInput(controlEl);
    this.addDeleteButton(controlEl);
  }
  addYPositionInput(containerEl) {
    const label = containerEl.createEl("label", { text: "y-position" });
    const slider = containerEl.createEl("input", {
      type: "range",
      cls: "slider",
      attr: {
        min: "0",
        max: "100",
        step: "1"
      }
    });
    slider.value = this.folderImage.yPosition || "50";
    slider.style.marginLeft = "20px";
    slider.addEventListener("change", async () => {
      this.folderImage.yPosition = parseInt(slider.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(slider);
  }
  addContentStartInput(containerEl) {
    const label = containerEl.createEl("label", { text: "content start position" });
    label.style.marginLeft = "18px";
    const contentStartInput = containerEl.createEl("input", {
      type: "number",
      attr: {
        min: "0"
      }
    });
    contentStartInput.style.width = "50px";
    contentStartInput.style.marginLeft = "20px";
    contentStartInput.value = this.folderImage.contentStartPosition || "150";
    contentStartInput.addEventListener("change", async () => {
      this.folderImage.contentStartPosition = parseInt(contentStartInput.value);
      await this.plugin.saveSettings();
    });
    label.appendChild(contentStartInput);
  }
  addDeleteButton(containerEl) {
    const deleteButton = containerEl.createEl("button");
    deleteButton.style.marginLeft = "50px";
    deleteButton.style.width = "50px";
    deleteButton.style.border = "1px solid #80000030";
    deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-trash-2"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
    deleteButton.addEventListener("click", async () => {
      this.plugin.settings.folderImages.splice(this.index, 1);
      await this.plugin.saveSettings();
      this.settingEl.remove();
      if (this.onDelete) {
        this.onDelete();
      }
    });
    deleteButton.addEventListener("mouseover", () => {
      deleteButton.style.color = "red";
    });
    deleteButton.addEventListener("mouseout", () => {
      deleteButton.style.color = "";
    });
  }
};
function arrayToString(arr) {
  return Array.isArray(arr) ? arr.join(", ") : arr;
}
function stringToArray(str) {
  return str.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
}
function validateFieldNames(settings, allFields, currentField, newNames) {
  const validNamePattern = /^[a-zA-Z0-9_-]+$/;
  const invalidNames = newNames.filter((name) => !validNamePattern.test(name));
  if (invalidNames.length > 0) {
    return {
      isValid: false,
      message: `Invalid characters in field names (only letters, numbers, dashes, and underscores allowed): ${invalidNames.join(", ")}`
    };
  }
  const otherFields = allFields.filter((f) => f !== currentField);
  const otherFieldNames = otherFields.flatMap((f) => settings[f]);
  const duplicates = newNames.filter((name) => otherFieldNames.includes(name));
  if (duplicates.length > 0) {
    return {
      isValid: false,
      message: `Duplicate field names found: ${duplicates.join(", ")}`
    };
  }
  return { isValid: true };
}
var PixelBannerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("pixel-banner-settings");
    const mainContent = containerEl.createEl("div", { cls: "pixel-banner-main-content" });
    const { tabsEl, tabContentContainer } = this.createTabs(mainContent, ["API Settings", "General", "Custom Field Names", "Folder Images", "Examples"]);
    const apiTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "API Settings" } });
    this.createAPISettings(apiTab);
    const generalTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "General" } });
    this.createGeneralSettings(generalTab);
    const customFieldsTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Custom Field Names" } });
    this.createCustomFieldsSettings(customFieldsTab);
    const foldersTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Folder Images" } });
    this.createFolderSettings(foldersTab);
    const examplesTab = tabContentContainer.createEl("div", { cls: "tab-content", attr: { "data-tab": "Examples" } });
    this.createExampleSettings(examplesTab);
    tabsEl.firstChild.click();
  }
  createTabs(containerEl, tabNames) {
    const tabsEl = containerEl.createEl("div", { cls: "pixel-banner-settings-tabs" });
    const tabContentContainer = containerEl.createEl("div", { cls: "pixel-banner-settings-tab-content-container" });
    tabNames.forEach((tabName) => {
      const tabEl = tabsEl.createEl("button", { cls: "pixel-banner-settings-tab", text: tabName });
      tabEl.addEventListener("click", () => {
        tabsEl.querySelectorAll(".pixel-banner-settings-tab").forEach((tab) => tab.removeClass("active"));
        tabContentContainer.querySelectorAll(".tab-content").forEach((content) => content.style.display = "none");
        tabEl.addClass("active");
        tabContentContainer.querySelector(`.tab-content[data-tab="${tabName}"]`).style.display = "block";
      });
    });
    return { tabsEl, tabContentContainer };
  }
  createAPISettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "callout" });
    calloutEl.createEl("p", { text: "Optionally select which API provider to use for fetching images. See the Examples tab for more information on referencing images by URL or local image. You can use any combination of API keyword, URL, or local image between notes." });
    calloutEl.style.backgroundColor = "var(--background-primary-alt)";
    calloutEl.style.border = "1px solid var(--background-modifier-border)";
    calloutEl.style.color = "var(--text-accent)";
    calloutEl.style.fontSize = "0.9em";
    calloutEl.style.borderRadius = "5px";
    calloutEl.style.padding = "0 25px";
    calloutEl.style.marginBottom = "20px";
    new import_obsidian.Setting(containerEl).setName("API Provider").setDesc("Select the API provider for fetching images").addDropdown((dropdown) => dropdown.addOption("pexels", "Pexels").addOption("pixabay", "Pixabay").setValue(this.plugin.settings.apiProvider).onChange(async (value) => {
      this.plugin.settings.apiProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(containerEl).setName("Pexels API Key");
    containerEl.createEl("span", { text: "Enter your Pexels API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://www.pexels.com/api/", text: "Pexels API" });
    const pexelsApiKeySetting = new import_obsidian.Setting(containerEl).addText((text) => {
      text.setPlaceholder("Pexels API key").setValue(this.plugin.settings.pexelsApiKey).onChange(async (value) => {
        this.plugin.settings.pexelsApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "100%";
    });
    pexelsApiKeySetting.settingEl.addClass("full-width-control");
    new import_obsidian.Setting(containerEl).setName("Pixabay API Key");
    containerEl.createEl("span", { text: "Enter your Pixabay API key. Get your API key from ", cls: "setting-item-description" }).createEl("a", { href: "https://pixabay.com/api/docs/", text: "Pixabay API" });
    const pixabayApiKeySetting = new import_obsidian.Setting(containerEl).addText((text) => {
      text.setPlaceholder("Pixabay API key").setValue(this.plugin.settings.pixabayApiKey).onChange(async (value) => {
        this.plugin.settings.pixabayApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "100%";
    });
    pixabayApiKeySetting.settingEl.addClass("full-width-control");
    new import_obsidian.Setting(containerEl).setName("Images").setDesc("Configure settings for images fetched from API. These settings apply when using keywords to fetch random images.").setHeading();
    new import_obsidian.Setting(containerEl).setName("Size").setDesc("Select the size of the image - (API only)").addDropdown((dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.plugin.settings.imageSize).onChange(async (value) => {
      this.plugin.settings.imageSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Orientation").setDesc("Select the orientation of the image - (API only)").addDropdown((dropdown) => dropdown.addOption("landscape", "Landscape").addOption("portrait", "Portrait").addOption("square", "Square").setValue(this.plugin.settings.imageOrientation).onChange(async (value) => {
      this.plugin.settings.imageOrientation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Number of images").setDesc("Enter the number of random images to fetch (3-50) - (API only)").addText((text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.numberOfImages || 10)).onChange(async (value) => {
      let numValue = Number(value);
      if (!isNaN(numValue)) {
        numValue = Math.max(3, Math.min(numValue, 50));
        this.plugin.settings.numberOfImages = numValue;
        await this.plugin.saveSettings();
      }
    })).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      inputEl.type = "number";
      inputEl.min = "3";
      inputEl.max = "50";
      inputEl.style.width = "50px";
    });
    const defaultKeywordsSetting = new import_obsidian.Setting(containerEl).setName("Default keywords").setDesc("Enter a comma-separated list of default keywords to be used when no keyword is provided in the frontmatter, or when the provided keyword does not return any results. - (API only)").addTextArea((text) => {
      text.setPlaceholder("Enter keywords, separated by commas").setValue(this.plugin.settings.defaultKeywords).onChange(async (value) => {
        this.plugin.settings.defaultKeywords = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.style.width = "100%";
      text.inputEl.style.marginTop = "15px";
      text.inputEl.style.height = "90px";
    }).addExtraButton(
      (button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.defaultKeywords = DEFAULT_SETTINGS.defaultKeywords;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    defaultKeywordsSetting.settingEl.dataset.id = "defaultKeywords";
    defaultKeywordsSetting.settingEl.style.display = "flex";
    defaultKeywordsSetting.settingEl.style.flexDirection = "column";
  }
  createGeneralSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "callout" });
    calloutEl.createEl("p", { text: "Set the default vertical position of the image, how it should be displayed, and where the content should start. These are global settings and apply to all notes with banners unless overridden by folder or note-specific settings." });
    calloutEl.style.backgroundColor = "var(--background-primary-alt)";
    calloutEl.style.border = "1px solid var(--background-modifier-border)";
    calloutEl.style.color = "var(--text-accent)";
    calloutEl.style.fontSize = "0.9em";
    calloutEl.style.borderRadius = "5px";
    calloutEl.style.padding = "0 25px";
    calloutEl.style.marginBottom = "20px";
    new import_obsidian.Setting(containerEl).setName("Image Vertical Position").setDesc("Set the vertical position of the image (0-100)").addSlider(
      (slider) => slider.setLimits(0, 100, 1).setValue(this.plugin.settings.yPosition).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.yPosition = value;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Content Start Position").setDesc("Set the default vertical position where the content starts (in pixels)").addText((text) => text.setPlaceholder("150").setValue(String(this.plugin.settings.contentStartPosition)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue >= 0) {
        this.plugin.settings.contentStartPosition = numValue;
        await this.plugin.saveSettings();
        this.plugin.updateAllBanners();
      }
    })).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      inputEl.type = "number";
      inputEl.min = "0";
      inputEl.style.width = "60px";
    });
    new import_obsidian.Setting(containerEl).setName("Image Display").setDesc("Set how the banner image should be displayed").addDropdown((dropdown) => dropdown.addOption("auto", "Auto").addOption("cover", "Cover").addOption("contain", "Contain").setValue(this.plugin.settings.imageDisplay || "cover").onChange(async (value) => {
      this.plugin.settings.imageDisplay = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
    }));
    new import_obsidian.Setting(containerEl).setName("Image Repeat").setDesc('Enable image repetition when "Contain" is selected').addToggle((toggle) => toggle.setValue(this.plugin.settings.imageRepeat || false).onChange(async (value) => {
      this.plugin.settings.imageRepeat = value;
      await this.plugin.saveSettings();
      this.plugin.updateAllBanners();
    }));
  }
  createCustomFieldsSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "callout" });
    calloutEl.createEl("p", { text: 'Customize the frontmatter field names used for the banner and Y-position. You can define multiple names for each field, separated by commas. Field names can only contain letters, numbers, dashes, and underscores. Example: "banner, pixel-banner, header_image" could all be used as the banner field name.' });
    calloutEl.style.backgroundColor = "var(--background-primary-alt)";
    calloutEl.style.border = "1px solid var(--background-modifier-border)";
    calloutEl.style.color = "var(--text-accent)";
    calloutEl.style.fontSize = "0.9em";
    calloutEl.style.borderRadius = "5px";
    calloutEl.style.padding = "0 25px";
    calloutEl.style.marginBottom = "20px";
    const customFields = [
      {
        setting: "customBannerField",
        name: "Banner Field Names",
        desc: "Set custom field names for the banner in frontmatter (comma-separated)",
        placeholder: "banner, pixel-banner, header-image"
      },
      {
        setting: "customYPositionField",
        name: "Y-Position Field Names",
        desc: "Set custom field names for the Y-position in frontmatter (comma-separated)",
        placeholder: "banner-y, y-position, banner-offset"
      },
      {
        setting: "customContentStartField",
        name: "Content Start Position Field Names",
        desc: "Set custom field names for the content start position in frontmatter (comma-separated)",
        placeholder: "content-start, start-position, content-offset"
      },
      {
        setting: "customImageDisplayField",
        name: "Image Display Field Names",
        desc: "Set custom field names for the image display in frontmatter (comma-separated)",
        placeholder: "banner-display, image-display, display-mode"
      },
      {
        setting: "customImageRepeatField",
        name: "Image Repeat Field Names",
        desc: "Set custom field names for the image repeat in frontmatter (comma-separated)",
        placeholder: "banner-repeat, image-repeat, repeat-image"
      }
    ];
    customFields.forEach((field) => {
      new import_obsidian.Setting(containerEl).setName(field.name).setDesc(field.desc).addText((text) => {
        text.setPlaceholder(field.placeholder).setValue(arrayToString(this.plugin.settings[field.setting])).onChange(async (value) => {
          const newNames = stringToArray(value);
          const validation = validateFieldNames(
            this.plugin.settings,
            customFields.map((f) => f.setting),
            field.setting,
            newNames
          );
          if (validation.isValid) {
            this.plugin.settings[field.setting] = newNames;
            await this.plugin.saveSettings();
          } else {
            new Notice(validation.message);
            text.setValue(arrayToString(this.plugin.settings[field.setting]));
          }
        });
        text.inputEl.style.width = "220px";
      }).addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings[field.setting] = DEFAULT_SETTINGS[field.setting];
        await this.plugin.saveSettings();
        this.display();
      }));
    });
  }
  createFolderSettings(containerEl) {
    const calloutEl = containerEl.createEl("div", { cls: "callout" });
    calloutEl.createEl("p", { text: "Set default banner images for specific folders. These will apply to all notes in the folder unless overridden by note-specific settings." });
    calloutEl.style.backgroundColor = "var(--background-primary-alt)";
    calloutEl.style.border = "1px solid var(--background-modifier-border)";
    calloutEl.style.color = "var(--text-accent)";
    calloutEl.style.fontSize = "0.9em";
    calloutEl.style.borderRadius = "5px";
    calloutEl.style.padding = "0 25px";
    calloutEl.style.marginBottom = "20px";
    const folderImagesContainer = containerEl.createDiv("folder-images-container");
    const updateFolderSettings = () => {
      folderImagesContainer.empty();
      this.plugin.settings.folderImages.forEach((folderImage, index) => {
        new FolderImageSetting(folderImagesContainer, this.plugin, folderImage, index, updateFolderSettings);
      });
    };
    updateFolderSettings();
    new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("+ Add Folder Image Setting").onClick(async () => {
      this.plugin.settings.folderImages.push({ folder: "", image: "", yPosition: 50, contentStartPosition: 150 });
      await this.plugin.saveSettings();
      updateFolderSettings();
    }));
  }
  createExampleSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("How to use").setHeading();
    const getRandomFieldName = (fieldNames) => {
      const names = Array.isArray(fieldNames) ? fieldNames : [fieldNames];
      return names[Math.floor(Math.random() * names.length)];
    };
    const instructionsEl = containerEl.createEl("div", { cls: "pixel-banner-section" });
    instructionsEl.createEl("p", { text: "Add the following fields to your note's frontmatter to customize the banner:" });
    const codeEl = instructionsEl.createEl("pre");
    codeEl.createEl("code", {
      text: `---
${getRandomFieldName(this.plugin.settings.customBannerField)}: blue turtle
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 30
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 200
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: contain
${getRandomFieldName(this.plugin.settings.customImageRepeatField)}: true
---

# Or use a direct URL:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: https://example.com/image.jpg
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 70
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 180
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: cover
---

# Or use a path to an image in the vault:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: Assets/my-image.png
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 0
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 100
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: auto
---

# Or use an Obsidian internal link:
---
${getRandomFieldName(this.plugin.settings.customBannerField)}: [[example-image.png]]
${getRandomFieldName(this.plugin.settings.customYPositionField)}: 100
${getRandomFieldName(this.plugin.settings.customContentStartField)}: 50
${getRandomFieldName(this.plugin.settings.customImageDisplayField)}: contain
${getRandomFieldName(this.plugin.settings.customImageRepeatField)}: false
---`
    });
    instructionsEl.createEl("p", { text: 'Note: The image display options are "auto", "cover", or "contain". The image repeat option is only applicable when the display is set to "contain".' });
    containerEl.createEl("img", {
      attr: {
        src: "https://raw.githubusercontent.com/jparkerweb/pixel-banner/main/example.jpg",
        alt: "Example of a Pixel banner",
        style: "max-width: 100%; height: auto; margin-top: 10px; border-radius: 5px;"
      }
    });
  }
  validateFieldName(value, otherFieldName) {
    if (value === otherFieldName) {
      new Notice("Field names must be unique!");
      return false;
    }
    return true;
  }
};
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// src/main.js
module.exports = class PixelBannerPlugin extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "debounceTimer", null);
    __publicField(this, "loadedImages", /* @__PURE__ */ new Map());
    __publicField(this, "lastKeywords", /* @__PURE__ */ new Map());
    __publicField(this, "imageCache", /* @__PURE__ */ new Map());
    __publicField(this, "rateLimiter", {
      lastRequestTime: 0,
      minInterval: 1e3
      // 1 second between requests
    });
    __publicField(this, "lastYPositions", /* @__PURE__ */ new Map());
    __publicField(this, "lastFrontmatter", /* @__PURE__ */ new Map());
    __publicField(this, "debouncedEnsureBanner", debounce(() => {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && activeLeaf.view instanceof import_obsidian2.MarkdownView) {
        this.updateBanner(activeLeaf.view, false);
      }
    }, 100));
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PixelBannerSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange.bind(this))
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", this.handleMetadataChange.bind(this))
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", this.handleLayoutChange.bind(this))
    );
    this.registerEvent(
      this.app.workspace.on("mode-change", this.handleModeChange.bind(this))
    );
    this.registerMarkdownPostProcessor(this.postProcessor.bind(this));
    this.setupMutationObserver();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (!Array.isArray(this.settings.folderImages)) {
      this.settings.folderImages = [];
    }
    if (this.settings.folderImages) {
      this.settings.folderImages.forEach((folderImage) => {
        folderImage.imageDisplay = folderImage.imageDisplay || "cover";
        folderImage.imageRepeat = folderImage.imageRepeat || false;
      });
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.loadedImages.clear();
    this.lastKeywords.clear();
    this.imageCache.clear();
    const activeLeaf = this.app.workspace.activeLeaf;
    if (activeLeaf && activeLeaf.view.getViewType() === "markdown") {
      await this.updateBanner(activeLeaf.view, true);
    }
  }
  async handleActiveLeafChange(leaf) {
    if (leaf && leaf.view instanceof import_obsidian2.MarkdownView && leaf.view.file) {
      await this.updateBanner(leaf.view, false);
    }
  }
  async handleMetadataChange(file) {
    var _a;
    const activeLeaf = this.app.workspace.activeLeaf;
    if (activeLeaf && activeLeaf.view instanceof import_obsidian2.MarkdownView && activeLeaf.view.file && activeLeaf.view.file === file) {
      const currentFrontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const cachedFrontmatter = this.lastFrontmatter.get(file.path);
      if (this.isFrontmatterChange(cachedFrontmatter, currentFrontmatter)) {
        this.lastFrontmatter.set(file.path, currentFrontmatter);
        await this.updateBanner(activeLeaf.view, true);
      }
    }
  }
  isFrontmatterChange(cachedFrontmatter, currentFrontmatter) {
    if (!cachedFrontmatter && !currentFrontmatter) return false;
    if (!cachedFrontmatter || !currentFrontmatter) return true;
    return JSON.stringify(cachedFrontmatter) !== JSON.stringify(currentFrontmatter);
  }
  handleLayoutChange() {
    setTimeout(() => {
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf && (activeLeaf.view instanceof import_obsidian2.MarkdownView || activeLeaf.view.getViewType() === "markdown")) {
        this.updateBanner(activeLeaf.view, false);
      }
    }, 100);
  }
  async handleModeChange(leaf) {
    if (leaf && leaf.view instanceof import_obsidian2.MarkdownView && leaf.view.file) {
      await this.updateBanner(leaf.view, true);
    }
  }
  async updateBanner(view, isContentChange) {
    var _a;
    if (!view || !view.file) {
      return;
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(view.file)) == null ? void 0 : _a.frontmatter;
    const contentEl = view.contentEl;
    let yPosition = this.settings.yPosition;
    let contentStartPosition = this.settings.contentStartPosition;
    let bannerImage = getFrontmatterValue(frontmatter, this.settings.customBannerField);
    const folderSpecific = this.getFolderSpecificImage(view.file.path);
    if (folderSpecific) {
      bannerImage = bannerImage || folderSpecific.image;
      yPosition = folderSpecific.yPosition;
      contentStartPosition = folderSpecific.contentStartPosition;
    }
    if (frontmatter) {
      const customYPosition = getFrontmatterValue(frontmatter, this.settings.customYPositionField);
      if (customYPosition !== void 0) {
        yPosition = customYPosition;
      }
      const customContentStart = getFrontmatterValue(frontmatter, this.settings.customContentStartField);
      if (customContentStart !== void 0) {
        contentStartPosition = customContentStart;
      }
    }
    if (isContentChange) {
      this.loadedImages.delete(view.file.path);
      this.lastKeywords.delete(view.file.path);
    }
    await this.addPixelBanner(contentEl, {
      frontmatter,
      file: view.file,
      isContentChange,
      yPosition,
      contentStartPosition,
      customBannerField: this.settings.customBannerField,
      customYPositionField: this.settings.customYPositionField,
      customContentStartField: this.settings.customContentStartField,
      bannerImage,
      isReadingView: view.getMode && view.getMode() === "preview"
    });
    this.lastYPositions.set(view.file.path, yPosition);
    const embeddedNotes = contentEl.querySelectorAll(".internal-embed");
    for (const embed of embeddedNotes) {
      const embedFile = this.app.metadataCache.getFirstLinkpathDest(embed.getAttribute("src"), "");
      if (embedFile) {
        const embedView = {
          file: embedFile,
          contentEl: embed,
          getMode: () => "preview"
        };
        await this.updateBanner(embedView, false);
      }
    }
  }
  async addPixelBanner(el, ctx) {
    const { frontmatter, file, isContentChange, yPosition, contentStartPosition, bannerImage, isReadingView } = ctx;
    const viewContent = el;
    const isEmbedded = viewContent.classList.contains("internal-embed");
    if (!isEmbedded && !viewContent.classList.contains("view-content")) {
      return;
    }
    viewContent.classList.toggle("pixel-banner", !!bannerImage);
    let container;
    if (isEmbedded) {
      container = viewContent.querySelector(".markdown-embed-content");
    } else {
      container = isReadingView ? viewContent.querySelector(".markdown-preview-sizer:not(.internal-embed .markdown-preview-sizer)") : viewContent.querySelector(".cm-sizer");
    }
    if (!container) {
      return;
    }
    let bannerDiv = container.querySelector(":scope > .pixel-banner-image");
    if (!bannerDiv) {
      bannerDiv = createDiv({ cls: "pixel-banner-image" });
      container.insertBefore(bannerDiv, container.firstChild);
    }
    if (bannerImage) {
      let imageUrl = this.loadedImages.get(file.path);
      const lastInput = this.lastKeywords.get(file.path);
      if (!imageUrl || isContentChange && bannerImage !== lastInput) {
        imageUrl = await this.getImageUrl(this.getInputType(bannerImage), bannerImage);
        if (imageUrl) {
          this.loadedImages.set(file.path, imageUrl);
          this.lastKeywords.set(file.path, bannerImage);
        }
      }
      if (imageUrl) {
        bannerDiv.style.backgroundImage = `url('${imageUrl}')`;
        bannerDiv.style.backgroundPosition = `center ${yPosition}%`;
        bannerDiv.style.backgroundSize = frontmatter[this.settings.customImageDisplayField] || this.getFolderSpecificSetting(file.path, "imageDisplay") || this.settings.imageDisplay || "cover";
        if (bannerDiv.style.backgroundSize === "contain") {
          bannerDiv.style.backgroundRepeat = (frontmatter[this.settings.customImageRepeatField] !== void 0 ? frontmatter[this.settings.customImageRepeatField] : this.getFolderSpecificSetting(file.path, "imageRepeat") !== void 0 ? this.getFolderSpecificSetting(file.path, "imageRepeat") : this.settings.imageRepeat) ? "repeat" : "no-repeat";
        } else {
          bannerDiv.style.backgroundRepeat = "no-repeat";
        }
        bannerDiv.style.display = "block";
      }
    } else {
      bannerDiv.style.display = "none";
      this.loadedImages.delete(file.path);
      this.lastKeywords.delete(file.path);
      this.applyContentStartPosition(viewContent, 0);
    }
    this.applyContentStartPosition(viewContent, contentStartPosition);
  }
  setupMutationObserver() {
    this.observer = new MutationObserver((mutations) => {
      for (let mutation of mutations) {
        if (mutation.type === "childList") {
          const removedNodes = Array.from(mutation.removedNodes);
          const addedNodes = Array.from(mutation.addedNodes);
          const bannerRemoved = removedNodes.some(
            (node) => node.classList && node.classList.contains("pixel-banner-image")
          );
          const contentChanged = addedNodes.some(
            (node) => node.nodeType === Node.ELEMENT_NODE && (node.classList.contains("markdown-preview-section") || node.classList.contains("cm-content"))
          );
          if (bannerRemoved || contentChanged) {
            this.debouncedEnsureBanner();
          }
        }
      }
    });
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  getFolderSpecificImage(filePath) {
    const folderPath = this.getFolderPath(filePath);
    for (const folderImage of this.settings.folderImages) {
      if (folderPath.startsWith(folderImage.folder)) {
        return {
          image: folderImage.image,
          yPosition: folderImage.yPosition,
          contentStartPosition: folderImage.contentStartPosition
        };
      }
    }
    return null;
  }
  getFolderPath(filePath) {
    const lastSlashIndex = filePath.lastIndexOf("/");
    return lastSlashIndex !== -1 ? filePath.substring(0, lastSlashIndex) : "";
  }
  async getImageUrl(type, input) {
    if (type === "url" || type === "path") {
      return input;
    }
    if (type === "obsidianLink") {
      const file = this.getPathFromObsidianLink(input);
      if (file) {
        return this.getVaultImageUrl(file.path);
      }
      return null;
    }
    if (type === "vaultPath") {
      return this.getVaultImageUrl(input);
    }
    if (type === "keyword") {
      if (this.settings.apiProvider === "pexels") {
        return this.fetchPexelsImage(input);
      } else if (this.settings.apiProvider === "pixabay") {
        return this.fetchPixabayImage(input);
      }
    }
    return null;
  }
  async fetchPexelsImage(keyword) {
    const apiKey = this.settings.pexelsApiKey;
    if (!apiKey) {
      new import_obsidian2.Notice("Pexels API key is not set. Please set it in the plugin settings.");
      return null;
    }
    const now = Date.now();
    if (now - this.rateLimiter.lastRequestTime < this.rateLimiter.minInterval) {
      await new Promise((resolve) => setTimeout(resolve, this.rateLimiter.minInterval));
    }
    this.rateLimiter.lastRequestTime = Date.now();
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const fallbackKeyword = defaultKeywords[Math.floor(Math.random() * defaultKeywords.length)];
    const keywords = [keyword, fallbackKeyword];
    for (const currentKeyword of keywords) {
      try {
        const response = await (0, import_obsidian2.requestUrl)({
          url: `https://api.pexels.com/v1/search?query=${encodeURIComponent(currentKeyword)}&per_page=${this.settings.numberOfImages}&size=${this.settings.imageSize}&orientation=${this.settings.imageOrientation}`,
          method: "GET",
          headers: {
            "Authorization": apiKey
          }
        });
        if (response.status !== 200) {
          console.error("Failed to fetch images:", response.status, response.text);
          continue;
        }
        const data = response.json;
        if (data.photos && data.photos.length > 0) {
          const randomIndex = Math.floor(Math.random() * data.photos.length);
          if (currentKeyword !== keyword) {
            console.log(`No image found for "${keyword}". Using image for "${currentKeyword}" instead.`);
          }
          const imageUrl = data.photos[randomIndex].src[this.settings.imageSize];
          try {
            await this.preloadImage(imageUrl);
          } catch (error) {
            console.error(`Failed to preload image: ${error.message}`);
          }
          return imageUrl;
        } else if (currentKeyword === keyword) {
          console.log(`No image found for the provided keyword: "${keyword}". Trying a random default keyword.`);
        }
      } catch (error) {
        console.error(`Error fetching image from API for keyword "${currentKeyword}":`, error);
        new import_obsidian2.Notice(`Failed to fetch image: ${error.message}`);
      }
    }
    console.error("No images found for any keywords, including the random default.");
    return null;
  }
  async fetchPixabayImage(keyword) {
    const apiKey = this.settings.pixabayApiKey;
    if (!apiKey) {
      new import_obsidian2.Notice("Pixabay API key is not set. Please set it in the plugin settings.");
      return null;
    }
    const defaultKeywords = this.settings.defaultKeywords.split(",").map((k) => k.trim());
    const keywordsToTry = [keyword, ...defaultKeywords];
    const maxAttempts = 5;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const currentKeyword = attempt === 0 ? keyword : keywordsToTry[Math.floor(Math.random() * keywordsToTry.length)];
      const apiUrl = "https://pixabay.com/api/";
      const params = new URLSearchParams({
        key: apiKey,
        q: encodeURIComponent(currentKeyword),
        image_type: "photo",
        per_page: this.settings.numberOfImages,
        safesearch: true
      });
      try {
        const response = await this.makeRequest(`${apiUrl}?${params}`);
        if (response.status !== 200) {
          console.error(`Pixabay API error: ${response.status} ${response.statusText}`);
          continue;
        }
        let data;
        if (response.arrayBuffer) {
          const text = new TextDecoder().decode(response.arrayBuffer);
          try {
            data = JSON.parse(text);
          } catch (error) {
            console.error("Failed to parse Pixabay response:", error);
            continue;
          }
        } else {
          console.error("Unexpected response format:", response);
          continue;
        }
        if (data.hits && data.hits.length > 0) {
          const imageUrls = data.hits.map((hit) => hit.largeImageURL);
          if (imageUrls.length > 0) {
            const randomIndex = Math.floor(Math.random() * imageUrls.length);
            const selectedImageUrl = imageUrls[randomIndex];
            return selectedImageUrl;
          }
        }
        console.log(`No images found for keyword: ${currentKeyword}`);
      } catch (error) {
        console.error("Error fetching image from Pixabay:", error);
      }
    }
    console.error("No images found after all attempts");
    new import_obsidian2.Notice("Failed to fetch an image after multiple attempts, try a different keyword and/or update the backup keyword list in settings.");
    return null;
  }
  async makeRequest(url) {
    const now = Date.now();
    if (now - this.rateLimiter.lastRequestTime < this.rateLimiter.minInterval) {
      await new Promise((resolve) => setTimeout(resolve, this.rateLimiter.minInterval));
    }
    this.rateLimiter.lastRequestTime = Date.now();
    try {
      const response = await (0, import_obsidian2.requestUrl)({ url });
      return response;
    } catch (error) {
      console.error("Request failed:", error);
      throw new Error(`Request failed: ${error.message}`);
    }
  }
  preloadImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(url);
      img.onerror = reject;
      img.src = url;
    });
  }
  getInputType(input) {
    if (typeof input !== "string") {
      return "invalid";
    }
    input = input.trim().replace(/^["'](.*)["']$/, "$1");
    if (input.includes("[[") && input.includes("]]")) {
      return "obsidianLink";
    }
    try {
      new URL(input);
      return "url";
    } catch (_) {
      const file = this.app.vault.getAbstractFileByPath(input);
      if (file && "extension" in file) {
        if (file.extension.match(/^(jpg|jpeg|png|gif|bmp|svg)$/i)) {
          return "vaultPath";
        }
      }
      return "keyword";
    }
  }
  getPathFromObsidianLink(link) {
    let innerLink = link.startsWith("[[") ? link.slice(2) : link;
    innerLink = innerLink.endsWith("]]") ? innerLink.slice(0, -2) : innerLink;
    const path = innerLink.split("|")[0];
    return this.app.metadataCache.getFirstLinkpathDest(path, "");
  }
  async getVaultImageUrl(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && "extension" in file) {
      try {
        const arrayBuffer = await this.app.vault.readBinary(file);
        const blob = new Blob([arrayBuffer], { type: `image/${file.extension}` });
        return URL.createObjectURL(blob);
      } catch (error) {
        console.error("Error reading vault image:", error);
        return null;
      }
    }
    return null;
  }
  updateAllBanners() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === "markdown") {
        this.updateBanner(leaf.view, true);
      }
    });
  }
  async postProcessor(el, ctx) {
    const frontmatter = ctx.frontmatter;
    if (frontmatter && frontmatter[this.settings.customBannerField]) {
      await this.addPixelBanner(el, {
        frontmatter,
        file: ctx.sourcePath,
        isContentChange: false,
        yPosition: frontmatter[this.settings.customYPositionField] || this.settings.yPosition,
        contentStartPosition: frontmatter[this.settings.customContentStartField] || this.settings.contentStartPosition,
        customBannerField: this.settings.customBannerField,
        customYPositionField: this.settings.customYPositionField,
        customContentStartField: this.settings.customContentStartField,
        customImageDisplayField: this.settings.customImageDisplayField,
        customImageRepeatField: this.settings.customImageRepeatField,
        bannerImage: frontmatter[this.settings.customBannerField]
      });
    }
  }
  onunload() {
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  applyContentStartPosition(el, contentStartPosition) {
    el.style.setProperty("--pixel-banner-content-start", `${contentStartPosition}px`);
  }
  getFolderSpecificSetting(filePath, settingName) {
    const folderPath = this.getFolderPath(filePath);
    for (const folderImage of this.settings.folderImages) {
      if (folderPath.startsWith(folderImage.folder)) {
        return folderImage[settingName];
      }
    }
    return void 0;
  }
};
function getFrontmatterValue(frontmatter, fieldNames) {
  if (!frontmatter || !Array.isArray(fieldNames)) return void 0;
  for (const fieldName of fieldNames) {
    if (fieldName in frontmatter) {
      return frontmatter[fieldName];
    }
  }
  return void 0;
}
